#ifndef MY_LMDP_H
#define MY_LMDP_H

#include "ns3/oran-data-repository.h"
#include "ns3/oran-lm.h"
#include <ns3/vector.h>
#include <fstream>

#include <map>
namespace ns3
{

class MyLmDp : public OranLm
{
  protected:
    /**
     * UE related information.
     */
    struct UeInfo
    {
        uint64_t nodeId; //!< The node ID.
        uint16_t cellId; //!< The cell ID.
        uint16_t rnti;   //!< The RNTI ID.
        double loss;     //!< The loss.
        std::vector<double> rsrp;
        uint64_t Rx;     //!< Recieved packet
        uint64_t Tx;     //!< Transport packet
        uint8_t mcs;     //!< MCS
        uint16_t sizetb;
        Vector position; //!< The physical position.
    };

    /**
     * eNB related information.
     */
    struct EnbInfo
    {
        uint64_t nodeId; //!< The node ID.
        uint16_t cellId; //!< The cell ID.
        Vector position; //!< The physical position.
    };

  public:
    /**
     * Gets the TypeId of the MyLmDp class.
     *
     * \return The TypeId.
     */
    static TypeId GetTypeId(void);
    /**
     * Constructor of the MyLmDp class.
     */
    MyLmDp(void);
    /**
     * Destructor of the MyLmDp class.
     */
    ~MyLmDp(void) override;
    /**
     * Runs the logic specific for this Logic Module. This will retrieve the
     * location of all LTE UEs and eNBs, find the closest eNB for each UE, and if
     * this eNB is not the serving eNB, a handover Command is generated.
     *
     * \return A vector with the handover commands generated by this Logic Module.
     */
    std::vector<Ptr<OranCommand>> Run(void) override;
    std::vector<Ptr<OranCommand>> GetHandoverCommands(
    	std::vector<MyLmDp::UeInfo> ueInfos,
        std::vector<MyLmDp::EnbInfo> enbInfos,
        Ptr<OranDataRepository> data,
        std::vector<uint16_t> &a);
    double value(double rsrp, int load);
    double solve(std::vector<MyLmDp::UeInfo> &ueInfos,int j,int c1,int c2,int c3,int c4,int l1,int l2,int l3,int l4);
    void saveData(std::vector<UeInfo> ueInfos, std::vector<uint16_t> a);
  private:
     double abr[20] {2.16427,2.11425,1.94947,1.85878,1.76809,1.70319,1.67707,1.67551,1.62342,1.57133,1.38448,1.19542,1.1548,1.07061,1.00457,1.001,0.906763,0.896566,0.88637,0.857012};
     int runTime;
     double M;
     double totalloss;
     double throughputRun;
     double throughputTotal;
     double dp[20][26][26][26][26] = {0};
     uint16_t assign[20][26][26][26][26] = {0};
     bool run;
     int d;
    /**
     * Method to get the UE information from the repository.
     *
     * \param data The data repository.
     *
     * \return A vector of UE Information structures.
     */
    std::vector<MyLmDp::UeInfo> GetUeInfos(
        Ptr<OranDataRepository> data, std::vector<MyLmDp::EnbInfo> enbinfos) const;
    /**
     * Method to get the eNB information from the repository.
     *
     * \param data The data repository.
     *
     * \return A vector of eNB Information structures.
     */
    std::vector<MyLmDp::EnbInfo> GetEnbInfos(
        Ptr<OranDataRepository> data) const;
    /**
     * Method with the logic to get the distance between UEs and eNBs
     * and generate Handover Commands if needed.
     *
     * \param data The data repository.
     * \param ueInfos A vector with the UE information.
     * \param enbInfos A vector with the eNB information.
     *
     * \return A vector with the handover commands generated.
     */
    
    double GetThroughput(std::vector<MyLmDp::UeInfo> ueInfos) const;
    double GetLoss(std::vector<MyLmDp::UeInfo> ueInfos) const;
};

} // namespace ns3

#endif
